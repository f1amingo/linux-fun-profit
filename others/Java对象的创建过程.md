# Java对象的创建过程

# Java中创建对象的几种方式

# Java new一个对象发生了什么

Java在new一个对象的时候，会先查看对象所属的类有没有被加载到内存，如果没有的话，就会先通过类的全限定名来加载。加载并初始化类完成后，再进行对象的创建工作。

我们先假设是第一次使用该类，这样的话new一个对象就可以分为两个过程： **加载并初始化类** 和 **创建对象**

## 类加载过程

虚拟机在遇到一条new指令时，首先将去检查这个指令的参数是否能够在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载、解析、和初始化过。如果没有，那么必须先执行相应的类加载过程。

### 1. 加载

### 2. 验证

### 3. 准备

### 4. 解析

### 5. 初始化

## 创建对象

### 1. 在堆区分配对象需要的内存

当类元信息被加载之后，我们就可以从常量池找到对应的类元信息，通过类元信息来确定类型和后面需要申请的内存大小。

分配的内存包括本类和父类的所有实例变量，但不包括任何静态变量

### 2. 对所有实例变量赋默认值

对象的内存分配完成后，还需要将对象的内存空间都初始化为零值，这样能保证对象即使没有赋初值，也可以直接使用。

分配完内存后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一项工作也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序能访问到这些字段的数据类型锁对应的零值。

### 3. 设置对象头

虚拟机还需要对对象进行其他必要的设置，设置的地方都在对象头中，包括这个对象所属的类，类的元数据信息，对象的hashcode，GC分代年龄等信息。

接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到这个类的元素据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象都会有不同的设置方式。

### 4. 执行实例初始化代码

上面的工作都完成后，从虚拟机角度来看，一个新的对象已经产生了，但从Java程序的角度来看，对象创建才刚刚开始——<init>方法还没执行，所有的字段都为零。所以，一般来说，执行new指令之后接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

然后执行对象内部生成的init方法，初始化成员变量值，同时执行搜集到的{}代码块逻辑，最后执行对象构造方法。执行对象的构造方法，这里做的操作才是程序员真正想做的操作，例如初始化其他对象啊等等操作，至此，对象创建成功。

初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法。

### 5. 栈区开辟空间

如果在方法内部使用，比如`Object obj = new Object()`，会在栈区申请引用类型变量`obj`的空间，然后将对象的地址赋值给它。

 

需要注意的是，**每个子类对象持有父类对象的引用**，可在内部通过super关键字来调用父类对象，但在外部不可访问。



### 内存分配

**指针碰撞**
 假设Java堆中的内存是绝对规整的，所有用过的内存都放在一边，空闲的放在另一边，中间放着一个指针作为分界点的指示器，那么分配内存就仅仅是把你就挨个指针向空闲的那边挪动一段与对象大小相等的距离。这种方式称为”指针碰撞“。

**空闲列表**
 如果Java堆的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没办法简单的进行指针碰撞了，虚拟机必须维护一个列表，记录哪些内存块是可用的，在分配内存的时候从列表中找到一块足够大小的空间划分给对象实例，并更新列表上的记录，这种方式被称为”空闲列表“。

### 虚方法表

### TLAB